"""
I am WaveTabulator, an n-dimensional (*) wavetable-inspired synthesizer constructor.

You select the number of dimensions, the size of the dimension (**), and a random seed.

I create a SunVox MetaModule that lets you address and mix synths along each dimension.

By default, I give you sound generators that create (mostly) tuned sounds based on gently randomized synths.

If you want, though, I be boring, and can just leave everything blank, for you to fill in yourself.

Regardless, you can replace the contents of these with anything you like!

I CAN BE CPU HEAVY! Remember that all synths are active regardless of being selected at a given time.

Demo videos:

- https://youtu.be/-UMQzHOZEzA

(*) where n is [1..5]

(**) where the dimension size is [2..16]
"""

from random import Random

from rv.api import m
from rv.controller import DependentRange, Range


# -[ Parameters ]----------------------------------------------------------------------------


MAX_RAND = 2 ** 30
SEED_RANGE = dict(range=(0, MAX_RAND))

synth_builder_fns = []


def set_parameters(p, P):
    p.surprise_me = P.Integer(0, **SEED_RANGE)
    p.volume_curve = P.String('linear', choices=['linear', 'parabolic'])
    p.dimensions = P.Integer(0, range=(1, 6))
    p.range1 = P.Integer(2, range=(2, 16))
    p.range2 = P.Integer(2, range=(2, 16))
    p.range3 = P.Integer(2, range=(2, 16))
    p.range4 = P.Integer(2, range=(2, 16))
    p.range5 = P.Integer(2, range=(2, 16))
    p.range6 = P.Integer(2, range=(2, 16))
    p.polyphony = P.Integer(1, range=(1, 32))
    p.detune = P.Integer(0, range=(0, 32))
    for builder in synth_builder_fns:
        name = builder.__name__
        p[name] = P.Integer(0, range=(0, 10))


# -[ Project builder ]----------------------------------------------------------------------------


synth_builders = []


def build_project(p, c, project, random=None):
    if c is not None:
        synth_builders[:] = []
        for builder in synth_builder_fns:
            name = builder.__name__
            synth_builders.extend([builder] * p[name])
        if not synth_builders:
            synth_builders.append(empty_synth)
        print(synth_builders)

    random = random or Random(p.surprise_me)

    note_in = project.new_module(m.MultiSynth, name='note in') if p.dimensions > 0 else None
    output = project.output

    ranges = [
        getattr(p, f'range{n + 1}')
        for n
        in range(p.dimensions)
    ]
    project.name = f"WT{p.surprise_me}-{'x'.join(map(str, ranges))}"

    if p.dimensions > 1:
        def build_synth_dimension(x):
            mod = project.new_module(m.MetaModule)
            p2 = type(p)(**p)
            p2.dimensions = p.dimensions - 1
            p2.range1 = p.range2
            p2.range2 = p.range3
            p2.range3 = p.range4
            p2.range4 = p.range5
            p2.range5 = p.range6
            p2.range6 = 2
            selectors = build_project(p2, None, mod.project, random)
            for selector in selectors:
                ctlindex = mod.user_defined_controllers
                mod.user_defined_controllers += 1
                mapping = mod.mappings.values[ctlindex]
                mapping.module = selector.index
                mapping.controller = 1
            return mod

        mods = [
            build_synth_dimension(x)
            for x
            in range(p.range1)
        ]
        filters = []
        for pos, mod in enumerate(mods):
            amp = project.new_module(m.Amplifier, volume=256 if pos == 0 else 0)
            filt = table_filter(project, p.volume_curve, pos, p.range1, amp, 1)
            filters.append((filt, 'value'))
            note_in >> mod >> amp >> output
        selectors = [m.MultiCtl.macro(project, *filters, name='selector')]
        for x in range(p.dimensions - 1):
            subselectors = [(mod, f'user_defined_{x + 1}') for mod in mods]
            selectors += [m.MultiCtl.macro(project, *subselectors, name='subselector')]
    elif p.dimensions == 1:
        filters = []
        for pos in range(p.range1):
            builder = random.choice(synth_builders)
            print('builder:', builder.__name__)
            mod = builder(project, random, p)
            mod.finetune = random.randint(-p.detune, p.detune)
            amp = project.new_module(m.Amplifier, volume=256 if pos == 0 else 0)
            filt = table_filter(project, p.volume_curve, pos, p.range1, amp, 1)
            filters.append((filt, 'value'))
            note_in >> mod >> amp >> project.output
        selectors = [m.MultiCtl.macro(project, *filters, name='selector')]
    else:
        selectors = []

    if c is not None:
        for x, selector in enumerate(selectors, 1):
            c.synth[f'dimension_{x}'] = (selector, 'value')

    project.layout(factor=(2, 4))
    return selectors


# -[ Synth builders ]----------------------------------------------------------------------------


def synth_builder(fn):
    synth_builder_fns.append(fn)
    return fn


@synth_builder
def empty_synth(project, random, p):
    return project.new_module(m.MetaModule)


@synth_builder
def analog_triangle(project, random, p):
    return project.new_module(
        m.AnalogGenerator,
        polyphony_ch=p.polyphony,
        waveform='triangle',
    )


@synth_builder
def analog_saw(project, random, p):
    return project.new_module(
        m.AnalogGenerator,
        polyphony_ch=p.polyphony,
        waveform='saw',
    )


@synth_builder
def analog_square(project, random, p):
    return project.new_module(
        m.AnalogGenerator,
        polyphony_ch=p.polyphony,
        waveform='square',
        duty_cycle=random.randint(0, 1024),
    )


@synth_builder
def analog_noise(project, random, p):
    return project.new_module(
        m.AnalogGenerator,
        polyphony_ch=p.polyphony,
        waveform='noise',
    )


@synth_builder
def analog_sin(project, random, p):
    return project.new_module(
        m.AnalogGenerator,
        polyphony_ch=p.polyphony,
        waveform='sin',
    )


@synth_builder
def analog_hsin(project, random, p):
    return project.new_module(
        m.AnalogGenerator,
        polyphony_ch=p.polyphony,
        waveform='hsin',
    )


@synth_builder
def analog_drawn(project, random, p):
    return project.new_module(
        m.AnalogGenerator,
        polyphony_ch=p.polyphony,
        waveform='drawn',
        samples=normalized([random.randint(0, 255) for x in range(32)]),
    )


@synth_builder
def analog_drawn_spline(project, random, p):
    return project.new_module(
        m.AnalogGenerator,
        polyphony_ch=p.polyphony,
        waveform='drawn_with_spline_interpolation',
        samples=normalized([random.randint(0, 255) for x in range(32)]),
    )


@synth_builder
def fm(project, random, p):
    mod = project.new_module(
        m.Fm,
        polyphony_ch=p.polyphony,
    )
    randomize_controllers(mod, random, include=[
        'c_freq_ratio',
        'm_freq_ratio',
    ])
    return mod


# -[ Utilities ]----------------------------------------------------------------------------


def table_filter(project, curve, pos, n, dest, ctl):
    amp = project.new_module(m.Amplifier, dc_offset=-128)
    mod1 = m.MultiCtl.macro(
        project,
        (amp, 'dc_offset'),  # dc offset
        name=f'Raw {pos + 1}',
    )
    if curve == 'linear':
        def fn(x, pos=pos):
            return int(max(0, min(32768, 32768 - 128 * abs(n * (x - (257 * pos) / n)))))
    elif curve == 'parabolic':
        def fn(x, pos=pos):
            return int(max(0, min(32768, 32768 - (0.707 * (n * (x - (pos * (257 / n))))) ** 2)))
    else:
        def fn(x, pos=pos):
            return 0
    mod1.curve.set_via_fn(fn)
    if pos == 0:  # wrap around from last to first
        mod1.curve.values = [v + fn(x, pos=n) for x, v in enumerate(mod1.curve.values)]
    s2c = project.new_module(
        m.Sound2Ctl,
        sample_rate_hz=8000,
        absolute=False,
        out_max=8192,
        out_controller=ctl,
        smooth=256,
    )
    amp >> s2c >> dest
    return mod1


def normalized(samples):
    # correct DC offset
    while (255 - max(*samples)) - min(*samples) not in [-1, 0, 1]:
        top = max(*samples)
        bottom = min(*samples)
        if 255 - top > bottom:
            samples = [x + 1 for x in samples]
        else:
            samples = [x - 1 for x in samples]
    # normalize
    distance = min(*samples) + (255 - max(*samples))
    ceiling = 255 - distance
    samples = [int(min(255, 255 * x / ceiling)) for x in samples]
    return samples


def randomize_controllers(mod, random, skip=None, include=None):
    if include is not None:
        choices = set(include)
    else:
        choices = set(mod.controllers)
    if skip is not None:
        choices -= set(skip)
    choices = sorted(list(choices))
    for ctlname, ctl in mod.controllers.items():
        if not ctl.attached(mod):
            choices.remove(ctlname)
    count = random.randint(0, len(choices))
    for _ in range(count):
        ctl_name = random.choice(choices)
        choices.remove(ctl_name)
        ctl = mod.controllers[ctl_name]
        t = ctl.value_type
        if isinstance(t, DependentRange):
            t = t.parent(mod)
        if isinstance(t, Range):
            value = random.randint(t.min, t.max)
        elif t is bool:
            value = random.choice([True, False])
        else:
            print(t)
            value = random.choice(list(t))
        print('setting {}.{} to {}'.format(mod, ctl_name, value))
        setattr(mod, ctl_name, value)
