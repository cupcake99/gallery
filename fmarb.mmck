{
  "project_factory_source": "from sf.mmck.project import *\nfrom rv.api import *\n\nfrom collections import defaultdict\n\n# Construct the MetaModule interior by\n# attaching modules to the `project` object.\n# Consult the `rv` documentation for details.\n# http://radiant-voices.rtfd.io/\n#\n# Expose controllers you'd like to manipulate\n# by adding them to the `c` object, using\n# `(module, ctl_name)` notation.\n#\n# Group them together using `Group` objects.\n#\n# Example:\n#\n#   gen = project.new_module(\n#       m.AnalogGenerator,\n#       polyphony_ch=1,\n#       sustain=False,\n#   )\n#   gen >> project.output\n#   c.attack = (gen, 'attack')\n#   c.release = (gen, 'release')\n\n\ndef sin_generator(group, name):\n    module = project.new_module(\n        m.AnalogGenerator,\n        name=name,\n        polyphony_ch=1,\n    )\n    group.waveform = (module, 'waveform')\n    group.sustain = (module, 'sustain')\n    group.attack = (module, 'attack')\n    group.release = (module, 'release')\n    group.duty_cycle = (module, 'duty_cycle')\n    return module\n\ndef operator(group, name):\n    return sin_generator(group, name)\n\noperator_factories = None\n\n# =========================\n\nproject.name = p.name\n\nnote_in = project.new_module(m.MultiSynth, name='note in')\n\nout_amp = project.new_module(m.Amplifier)\nout_amp >> project.output\nc.master_volume = (out_amp, 'volume')\n\nforward_graph = defaultdict(list)\nedges = [(src, dest) for src, dest in p.algorithm.split(' ')]\nfor src, dest in edges:\n    dest = src if dest == '-' else dest\n    node = forward_graph[src]\n    if dest not in node:\n        forward_graph[src].append(dest)\n\nreverse_graph = defaultdict(list)\nedges = [(src, dest) for src, dest in p.algorithm.split(' ')]\nfor src, dest in edges:\n    dest = src if dest == '-' else dest\n    node = reverse_graph[dest]\n    if src not in node:\n        reverse_graph[dest].append(src)\n\noperator_count = len(forward_graph)\n\noperator_names = set(forward_graph).union(set(reverse_graph))\noperator_names = list(sorted(operator_names))\noperator_names.remove('.')\n\noperator_factories = operator_factories or ([operator] * operator_count)\n\nfor name in operator_names:\n    c['operator_{}'.format(name)] = Group()\n\noperators = {}\noperator_c_amps = {}\noperator_m_amps = {}\noperator_mods = {}\noperator_multis = {}\nfor name, factory in zip(operator_names, operator_factories):\n    group = c['operator_{}'.format(name)]\n    multi = m.MultiSynth(name='{} note'.format(name))\n    oper = factory(group, name='{} oper'.format(name))\n    c_amp = m.Amplifier(name='{} c amp'.format(name))\n    m_amp = m.Amplifier(name='{} m amp'.format(name))\n    mod = m.Modulator(\n        modulation_type='phase', \n        name='{} mod'.format(name),\n    )\n    project += [multi, oper, c_amp, m_amp, mod]\n    multi >> oper >> c_amp >> mod\n    m_amp >> mod\n    operators[name] = oper\n    operator_c_amps[name] = c_amp\n    operator_m_amps[name] = m_amp\n    operator_mods[name] = mod\n    operator_multis[name] = multi\n    group.carrier_amp = (c_amp, 'volume')\n    group.modulator_amp = (m_amp, 'volume')\n\nfeedback_ctls = {}\nfor dest_key, src_keys in reverse_graph.items():\n    if dest_key == '.':\n        dest_amp = out_amp\n    else:\n        dest_amp = operator_m_amps[dest_key]\n    for src_key in src_keys:\n        src_mod = operator_mods[src_key]\n        if src_key == dest_key:\n            fb1 = project.new_module(m.Feedback, volume=0)\n            fb2 = project.new_module(m.Feedback, volume=0)\n            fb_ctl = project.new_module(\n                m.MultiCtl,\n                value=0,\n                name='{} fb'.format(src_key),\n                mappings=[\n                    (0, 32768, fb1.controllers['volume'].number),\n                    (0, 32768, fb2.controllers['volume'].number),\n                ]\n            )\n            src_m_amp = operator_m_amps[src_key]\n            src_mod >> fb1 >> fb2 >> src_m_amp\n            fb_ctl >> [fb1, fb2]\n            feedback_ctls[src_key] = fb_ctl\n            group = c['operator_{}'.format(src_key)]\n            group.feedback = (fb_ctl, 'value')\n        else:\n            src_mod >> dest_amp\n\nnote_in >> list(operator_multis.values())\n",
  "mmck_version": 1,
  "parameter_values": [
    [
      "name",
      "My FM Synth"
    ],
    [
      "algorithm",
      "4- 43 3. 2. 1."
    ]
  ],
  "parameter_factory_source": "from sf.mmck.parameters import *\n\n# Define your parameters below by adding to the\n# `p` object.\n#\n# You can define String or Integer parameters.\n#\n# Example:\n#\n#   p.name = String(label='Project Name')\n#   p.voices = Integer(5, range=(3, 17), step=2)\n#   p.spread = Integer(5, range=(0, 128))\n\np.name = String('My FM Synth', label='Project Name')\np.algorithm = String('4- 43 3. 2. 1.', label='Algorithm')\n"
}