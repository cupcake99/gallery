#                                    _      _            _
#                          __      _(_) ___| | _____  __| |
#                          \ \ /\ / / |/ __| |/ / _ \/ _` |
# Hear the drummer get...   \ V  V /| | (__|   <  __/ (_| |
#                            \_/\_/ |_|\___|_|\_\___|\__,_|
#

from itertools import cycle
from operator import add
from random import Random

import numpy as np
import py
import wavio

from rv.api import m, NOTE, NOTECMD, Pattern


# -[ Parameters ]----------------------------------------------------------------------------


MAX_RAND = 2 ** 30
SEED_RANGE = dict(range=(0, MAX_RAND))

DIGITS = [
    '0123456789',
    '0123456789abcdef',
    '0123456789abcdefghijklmnopqrstuvwxyz',
]


def set_parameters(p, P):

    p.name = P.String(label='Project Name')
    p.rhythm_seed = P.Integer(0, **SEED_RANGE)
    p.sample_seed = P.Integer(0, **SEED_RANGE)
    p.bpm = P.Integer(125, range=(60, 240))
    p.swing = P.Integer(0, range=(0, 5))
    p.accent_threshold = P.Integer(127, range=(0, 255))
    p.performer = P.String(PERFORMERS[0], choices=PERFORMERS)
    p.digits = P.String(DIGITS[0], choices=DIGITS)
    p.phrases = P.String('4444,4444,4444,4444')
    p.variations = P.Integer(1, range=(1, 16))

    for slot in range(8):
        def setslot(name, value, slot=slot):
            p['slot{}_{}'.format(slot + 1, name)] = value
        setslot('name', P.String('slot{}'.format(slot + 1)))
        setslot('paths', P.PathList())
        setslot('seed', P.Integer(0, **SEED_RANGE))
        setslot('samples', P.Integer(1, range=(1, 15)))
        setslot('phrase_strength', P.String('9'))
        setslot('phrase_wild', P.String('0'))
        setslot('note_chance', P.String('0'))
        setslot('note_accent', P.String('0'))
        setslot('note_variation', P.String('0'))
        setslot('velocity_variation', P.String('0'))

    p.slot1_name.default = 'kick'
    p.slot1_phrase_strength.default = '9'
    p.slot1_phrase_wild.default = '0,1,0,9'
    p.slot1_note_chance.default = '9132'
    p.slot1_note_accent.default = '9555'
    p.slot1_note_variation.default = '0555'

    p.slot2_name.default = 'snare'
    p.slot2_phrase_strength.default = '9,9,9,5'
    p.slot2_phrase_wild.default = '1,1,5,9'
    p.slot2_note_chance.default = '21149214'
    p.slot2_note_accent.default = '53339333'
    p.slot2_note_variation.default = '55550555'

    p.slot3_name.default = 'toms'
    p.slot3_phrase_strength.default = '1,1,1,7'
    p.slot3_phrase_wild.default = '1,4,1,9'
    p.slot3_note_chance.default = '864'
    p.slot3_note_accent.default = '522'
    p.slot3_note_variation.default = '64215'


# -[ Project builder ]----------------------------------------------------------------------------


def build_project(p, c, project):
    project.name = p.name or '{}-{}-synth'.format(p.rhythm_seed, p.sample_seed)
    project.initial_bpm = p.bpm

    note_in = project.new_module(m.MultiSynth, ignore_notes_with_zero_velocity=True)

    rrandom = Random(p.rhythm_seed)
    srandom = Random(p.sample_seed)
    new_seed = lambda x: (srandom.randint(0, MAX_RAND) + x) % MAX_RAND
    new_random = lambda x: Random(new_seed(x))
    slot_srandom = [
        new_random(p['slot{}_seed'.format(x)])
        for x in range(1, 9)
    ]
    samplefinders = [
        samplefinder(
            p['slot{}_name'.format(x)],
            p['slot{}_paths'.format(x)],
            new_random(p['slot{}_seed'.format(x)]),
        )
        for x in range(1, 9)
    ]
    slot_rrandom = [
        new_random(p['slot{}_seed'.format(x)] + p.rhythm_seed)
        for x in range(1, 9)
    ]
    slot_notes = [[] for _ in range(8)]
    slot_notegates = [[] for _ in range(8)]
    slot_samplepaths = [[] for _ in range(8)]
    slot_samplers = [[] for _ in range(8)]
    slot_transposers = [[] for _ in range(8)]

    def var(name, slot):
        return p['slot{}_{}'.format(slot + 1, name)]

    # Find samples; create groups.
    for slot, (find_sample, samples) in enumerate(
            zip(samplefinders, slot_samplepaths)):
        name = var('name', slot)
        sample_count = var('samples', slot)
        for i in range(sample_count):
            path = find_sample()
            if not path:
                continue
            samples.append(path)
        if not samples:
            continue
        group = c[name]

    # Do this after creating slot-specific groups.
    master_amp = project.new_module(m.Amplifier, name='master amp')
    master_amp >> project.output
    c.master.amp = (master_amp, 'volume')

    # Create samplers; load samples; wire them up.
    for slot, (paths, notegates, samplers, transposers) in enumerate(
            zip(slot_samplepaths, slot_notegates, slot_samplers, slot_transposers)):
        if not paths:
            continue
        name = var('name', slot)
        group = c[name]
        slot_amp = project.new_module(m.Amplifier, name='{} amp'.format(slot + 1))
        slot_amp >> master_amp
        group.amp = (slot_amp, 'volume')
        notegates = slot_notegates[slot]
        transposers = slot_transposers[slot]
        # Accent switch
        accents = project.new_module(
            m.MultiSynth, name='accents', ignore_notes_with_zero_velocity=True)
        no_accents = project.new_module(
            m.MultiSynth,
            name='no accents',
            velocity=0,
            vv_curve_active=True,
            ignore_notes_with_zero_velocity=True,
        )
        no_accents.vv_curve.set_via_fn(lambda v: min(p.accent_threshold, v))
        accent_gates = [accents, no_accents]
        accent_switch = m.MultiCtl.macro(
            project,
            (accents, 'velocity'),
            (no_accents, 'velocity'),
            name='accent',
        )
        accent_switch.quantization = 2
        mapping = accent_switch.mappings.values[1]
        mapping.min, mapping.max = mapping.max, mapping.min
        accent_switch.value = 32768
        accented = project.new_module(m.MultiSynth, name='accented', ignore_notes_with_zero_velocity=True)
        accent_switch >> accent_gates
        note_in >> accent_gates >> accented
        group.accent = (accent_switch, 'value')
        for i, path in enumerate(paths):
            # Wiring.
            notegate = project.new_module(m.MultiSynth, name='note gate', ignore_notes_with_zero_velocity=True)
            transposer = project.new_module(m.MultiSynth, name='transposer', ignore_notes_with_zero_velocity=True)
            sampler = project.new_module(m.Sampler, name='{}.{} - {}'.format(slot + 1, i + 1, path.basename))
            notegates.append(notegate)
            transposers.append(transposer)
            samplers.append(sampler)
            accented >> notegate >> transposer >> sampler >> slot_amp
            # Sample loading
            sample = m.Sampler.Sample()
            printed(path.basename, 'Reading {}'.format(name))
            w = wavio.read(str(path))
            nframes, nchannels = printed(w.data.shape, 'shape', mute=True)
            sample.rate = w.rate
            sample.channels = {
                1: m.Sampler.Channels.mono,
                2: m.Sampler.Channels.stereo,
            }[nchannels]
            # TODO: convert to 32-bit float
            if w.sampwidth == 2:
                data = w.data
                sample.format = m.Sampler.Format.int16
            elif w.sampwidth == 3:
                data = w.data >> 8
                sample.format = m.Sampler.Format.int16
                data = data.astype('int16')
            printed((data.min(), data.max()), 'min/max', mute=True)
            sample.data = data.tobytes()
            sample.finetune = 0
            sample.relative_note = 16
            sampler.samples[0] = sample
            c.samples['{}_{}_vol'.format(name, i + 1)] = (sampler, 'volume')
            printed('', mute=True)

    # Assign notes
    current_note = STARTING_NOTE
    for slot, (notes, notegates) in enumerate(zip(slot_notes, slot_notegates)):
        for notegate in notegates:
            notes.append(current_note)
            notegate.nv_curve.set_via_fn(lambda n: 0xff if n + 1 == current_note.value else 0x00)
            current_note = NOTE(current_note + 1)

    # Wire up transposers
    for slot, transposers in enumerate(slot_transposers):
        if not transposers:
            continue
        name = var('name', slot)
        group = c[name]
        transpose = m.MultiCtl.macro(project, *[(t, 'transpose') for t in transposers], name='transpose')
        for mapping in transpose.mappings.values:
            mapping.min, mapping.max = (128 - 32, 128 + 32)
        finetune = m.MultiCtl.macro(project, *[(t, 'finetune') for t in transposers], name='finetune')
        group.transpose = (transpose, 'value')
        group.finetune = (finetune, 'value')
        transpose.value = 0x4000
        finetune.value = 0x4000

    # Fill out UI to 8 controllers per slot
    macro = project.new_module(m.MultiCtl, name='_')
    for slot in range(8):
        if not slot_samplers[slot]:
            continue
        name = var('name', slot)
        group = c[name]
        while len(group) < 8:
            group['__{}__'.format(len(group) + 1)] = (macro, 'value')

    # Swing pattern.
    swing = Pattern(name='swing', tracks=1, x=0, y=-64)
    project += swing
    speeds = [6 + p.swing, 6 - p.swing]
    for line, speed in zip(range(swing.lines), cycle(speeds)):
        n = swing.data[line][0]
        n.effect = 0x0f
        n.val_yy = speed

    # Variation trigger pattern.
    variation_triggers = Pattern(name='variation triggers', tracks=1, x=0, y=-32)
    variation_transposer = project.new_module(m.MultiSynth, name='variation transposer')
    project += variation_triggers
    for line in range(variation_triggers.lines):
        n = variation_triggers.data[line][0]
        n.note = NOTECMD.C0
        n.vel = 129
        n.module = variation_transposer.index + 1

    variation_selector = m.MultiCtl.macro(
        project, (variation_transposer, 'transpose'), name='variation')
    variation_selector.gain = 256 + int(256 / (p.variations + 1))
    mapping = variation_selector.mappings.values[0]
    mapping.min, mapping.max = 128, 128 + p.variations
    c.master.variation = (variation_selector, 'value')

    # Initialize variations.
    variation_gates = []
    variation_patterns = []
    for i in range(p.variations + 1):
        pattern = Pattern(name=str(i + 1), tracks=8, x=0, y=32 * i)
        project += pattern
        variation_patterns.append(pattern)
        notegate = project.new_module(m.MultiSynth, name='note gate')
        notegate.nv_curve.set_via_fn(lambda n: 0xff if n == i else 0x00)
        vgate = project.new_module(m.MultiSynth, name='variation gate')
        variation_gates.append(vgate)
        v2c = project.new_module(m.Velocity2Ctl, name='velocity switch')
        v2c.out_controller = vgate.controllers['velocity'].number
        variation_transposer >> notegate >> v2c >> vgate >> note_in
        vgate.velocity = 256 if i == 0 else 0

    performer = globals().get(p.performer, None)
    if not callable(performer):
        performer = dummer
        print("{} didn't show up for work; dummer will perform instead".format(p.performer))
    else:
        print('{} is now performing'.format(p.performer))

    # Perform variations.
    def gentrack(pattern, mod, track, rrandom, notes):
        performance = performer(
            notes=notes,
            random=rrandom,
        )
        for line, (note, vel) in zip(range(pattern.lines), performance):
            if note:
                n = pattern.data[line][track]
                n.note = note
                n.module = vgate.index + 1
                n.vel = 1 + vel
    for pattern, vgate in zip(variation_patterns, variation_gates):
        for slot, (rrandom, notes) in enumerate(zip(slot_rrandom, slot_notes)):
            if not notes:
                continue
            gentrack(
                pattern=pattern,
                mod=vgate,
                track=slot,
                rrandom=rrandom,
                notes=notes,
            )

    # Make it pretty!
    project.layout(factor=(2, 4))


# -[ Performers ]----------------------------------------------------------------------------


PERFORMERS = []


def performer(fn):
    PERFORMERS.append(fn.__name__)
    return fn


@performer
def dummer(notes, random, **kwargs):
    while True:
        if random.random() > 0.5:
            yield (random.choice(notes), random.randint(0, 128))
        else:
            yield (None, None)


# -[ Utils ]----------------------------------------------------------------------------


FILE_URL_PREFIX = 'file://'
STARTING_NOTE = NOTE.C4


def printed(value, label=None, mute=False):
    if not mute:
        if label:
            print('{}: {!r}'.format(label, value))
        else:
            print(repr(value))
    return value


def samplefinder(name, paths, random):
    all_paths = set()
    for path in paths:
        if path.startswith(FILE_URL_PREFIX):
            path = path[len(FILE_URL_PREFIX):]
        try:
            all_paths.update(set(py.path.local(path).visit('*.wav')))
        except py.error.ENOENT:
            print('WARNING: path not found: {}'.format(path))
            pass
    all_paths = sorted(list(all_paths))
    def fn():
        choice = random.choice(all_paths) if all_paths else None
        return choice
    return fn


